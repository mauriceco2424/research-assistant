use std::fs;
use std::path::PathBuf;
use std::time::Duration;

use anyhow::{bail, Context};
use chrono::{DateTime, Utc};
use serde_json;
use uuid::Uuid;

use crate::bases::Base;
use crate::orchestration::events::{log_compile_attempted, WritingEventDetails};
use crate::orchestration::{
    MetricRecord, OrchestrationLog, WritingMetricKind, WritingMetricRecord,
};
use crate::writing::project::ProjectPaths;

use super::WritingResult;

/// Build statuses captured for compile attempts.
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum BuildStatus {
    Success,
    Failure,
    Skipped,
}

/// Metadata recorded for each build.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct BuildSession {
    pub id: Uuid,
    pub project_slug: String,
    pub compiler: String,
    pub started_at: DateTime<Utc>,
    pub completed_at: DateTime<Utc>,
    pub status: BuildStatus,
    pub log_path: PathBuf,
    pub pdf_path: Option<PathBuf>,
    #[serde(default)]
    pub error_summary: Option<String>,
}

/// Options provided by chat for compile requests.
pub struct CompileOptions {
    pub compiler: Option<String>,
    pub clean: bool,
}

/// Executes a local compile. This implementation writes stub artifacts and logs to keep flow testable.
pub fn compile_project(
    base: &Base,
    slug: &str,
    options: CompileOptions,
) -> WritingResult<BuildSession> {
    let started = std::time::Instant::now();
    let paths = ProjectPaths::new(base, slug);
    if !paths.project_root.exists() {
        bail!("Project '{}' not found. Run /writing start first.", slug);
    }
    if !has_drafts(&paths) {
        bail!("No drafts found in sections/. Generate drafts before compiling.");
    }

    fs::create_dir_all(&paths.builds_dir)
        .with_context(|| format!("Failed to create builds dir {}", paths.builds_dir.display()))?;

    let started_at = Utc::now();
    let build_id = Uuid::new_v4();
    let build_dir = paths
        .builds_dir
        .join(started_at.format("%Y%m%dT%H%M%SZ").to_string());
    fs::create_dir_all(&build_dir)?;

    let log_path = build_dir.join("build.log");
    let pdf_path = build_dir.join("main.pdf");
    let compiler = options.compiler.unwrap_or_else(|| "tectonic".to_string());

    let log_content = generate_stub_log(&compiler, &paths.main_tex_path);
    fs::write(&log_path, log_content.as_bytes())
        .with_context(|| format!("Failed to write log {}", log_path.display()))?;

    // Write a placeholder PDF to keep downstream tooling satisfied.
    fs::write(
        &pdf_path,
        b"% PDF placeholder generated by Writing Assistant\n",
    )
    .ok();

    // In a real implementation we would invoke the compiler and parse logs. Here we mark success if log wrote.
    let status = BuildStatus::Success;
    let completed_at = Utc::now();
    let session = BuildSession {
        id: build_id,
        project_slug: slug.to_string(),
        compiler: compiler.clone(),
        started_at,
        completed_at,
        status,
        log_path: log_path.clone(),
        pdf_path: Some(pdf_path.clone()),
        error_summary: None,
    };

    save_session(&paths, &session)?;
    log_compile_attempted(
        base,
        WritingEventDetails::with_payload(
            slug,
            serde_json::json!({
                "build_id": build_id,
                "compiler": compiler,
                "status": format!("{:?}", session.status),
            }),
        )
        .with_files_touched([
            log_path.display().to_string(),
            pdf_path.display().to_string(),
        ]),
    )?;
    record_compile_metric(
        base,
        started.elapsed(),
        true,
        serde_json::json!({
            "build_id": build_id,
            "log_exists": log_path.exists(),
            "pdf_exists": pdf_path.exists(),
        }),
    );

    Ok(session)
}

/// Parses build logs into user-friendly lines.
pub fn parse_logs(log_path: &PathBuf) -> WritingResult<Vec<String>> {
    if !log_path.exists() {
        return Ok(vec!["Build log missing.".to_string()]);
    }
    let content = fs::read_to_string(log_path)
        .with_context(|| format!("Failed to read build log {}", log_path.display()))?;
    let mut lines = Vec::new();
    for line in content.lines() {
        if line.to_ascii_lowercase().contains("error") {
            lines.push(format!("ERROR: {}", line.trim()));
        } else if line.to_ascii_lowercase().contains("warning") {
            lines.push(format!("WARN: {}", line.trim()));
        }
    }
    if lines.is_empty() {
        lines.push("Build completed without warnings.".to_string());
    }
    Ok(lines)
}

fn save_session(paths: &ProjectPaths, session: &BuildSession) -> WritingResult<()> {
    let meta_path = paths
        .builds_dir
        .join(format!("{}.json", session.id.to_string()));
    let data = serde_json::to_string_pretty(session)?;
    fs::write(&meta_path, data)
        .with_context(|| format!("Failed to write build session {}", meta_path.display()))?;
    Ok(())
}

fn has_drafts(paths: &ProjectPaths) -> bool {
    if !paths.sections_dir.exists() {
        return false;
    }
    if let Ok(entries) = fs::read_dir(&paths.sections_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
                if let Some(name) = entry.file_name().to_str() {
                    if name.ends_with(".tex") && name != ".gitkeep" {
                        return true;
                    }
                }
            }
        }
    }
    false
}

fn generate_stub_log(compiler: &str, main_tex: &PathBuf) -> String {
    let mut log = String::new();
    log.push_str(&format!(
        "Compiler: {} | Entry: {}\n",
        compiler,
        main_tex.display()
    ));
    log.push_str("No real compile executed; placeholder build for testing.\n");
    log.push_str(&format!("Completed in {:?}\n", Duration::from_millis(100)));
    log
}

fn record_compile_metric(
    base: &Base,
    duration: std::time::Duration,
    success: bool,
    details: serde_json::Value,
) {
    let log = OrchestrationLog::for_base(base);
    let _ = log.record_metric(&MetricRecord::Writing(WritingMetricRecord {
        kind: WritingMetricKind::Compile,
        duration_ms: duration.as_millis() as i64,
        success,
        details,
    }));
}
